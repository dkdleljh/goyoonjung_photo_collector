# 고윤정 사진 수집기 — 사용설명서

이 문서는 `goyoonjung_photo_collector`를 **처음 설치하고 안전하게 운영**하기 위한 “사용자용 매뉴얼”입니다.

- 대상: 개발자가 아니어도 따라할 수 있게 작성
- 원칙: **시크릿(토큰/키) 유출 방지**, 무리한 우회/스크래핑 금지

---

## 0) 이 프로그램이 하는 일

- 공개적으로 접근 가능한 소스에서 “고윤정” 관련 이미지를 찾아 다운로드합니다.
- 다운로드한 이미지를 로컬 폴더에 저장합니다.
- 저장한 이미지의 **sha256** 해시로 중복을 제거합니다.
- 실패/스킵도 이유를 기록합니다.

### 0.1 하지 않는 일(중요)

- 로그인 우회, 차단 우회, 비공개 콘텐츠 접근을 목표로 하지 않습니다.
- 유료 API/유료 서비스 연동을 기본으로 요구하지 않습니다.
- 실행 결과를 자동으로 외부(S3/Drive/Notion 등)로 업로드하지 않습니다.

---

## 1) 설치 전 준비물

- Python 3.11 이상
- 인터넷 연결
- (선택) NAVER 이미지 검색 Open API 키

---

## 2) 설치(가장 안전한 표준 절차)

아래는 Linux/macOS 기준입니다.

```bash
git clone https://github.com/dkdleljh/goyoonjung_photo_collector.git
cd goyoonjung_photo_collector

# 가상환경 생성 (프로젝트는 venv/ 폴더를 기본으로 사용)
python3 -m venv venv
source venv/bin/activate

pip install -r requirements.txt
```

Windows(PowerShell):

```powershell
git clone https://github.com/dkdleljh/goyoonjung_photo_collector.git
cd goyoonjung_photo_collector

py -3.11 -m venv venv
venv\Scripts\activate

pip install -r requirements.txt
```

---

## 3) 설정(.env) — 절대 커밋 금지

### 3.1 .env 만들기

```bash
cp .env.example .env
```

`.env`에는 아래 값이 들어갑니다.

- `NAVER_CLIENT_ID=`
- `NAVER_CLIENT_SECRET=`
- `PHOTO_ROOT=`

### 3.2 PHOTO_ROOT는 뭐예요?

저장 경로의 “Desktop 기준점”이 애매한 환경에서 수집 폴더를 확실히 고정하고 싶을 때 사용합니다.

- 비워두면: OS가 인식하는 Desktop 아래에 저장
- 지정하면: `${PHOTO_ROOT}/Goyoonjung_Photos` 아래에 저장

예시:

```env
PHOTO_ROOT=/home/you/Pictures
```

그러면 결과는 `/home/you/Pictures/Goyoonjung_Photos/` 로 저장됩니다.

### 3.3 보안 규칙(중요)

- `.env`는 절대 GitHub에 올리면 안 됩니다.
- 이 저장소는 `.gitignore`로 `.env`를 제외하지만, **직접 확인**하세요.

확인 명령:

```bash
git status --porcelain
```

여기에 `.env`가 보이면 즉시 멈추고 `.gitignore`/파일 위치를 점검하세요.

---

## 4) 1회 실행(가장 먼저 해볼 것)

### 4.1 드라이런(추천)

다운로드 없이 “후보 수집만” 해보는 모드입니다.

```bash
python -m app.cli run --once --dry-run
```

- 결과가 OK=0이어도 정상입니다(저장을 안 하니까요).
- 후보 수/유니크 URL 수가 찍히면 수집 로직은 살아있는 상태입니다.

참고: 실제 다운로드 시에는 기본 품질 게이트가 `min(width,height) >= 720px` 입니다.
저해상도 스팸을 막기 위한 기본값이며, 필요하면 코드/설정으로 조정할 수 있습니다.

### 4.2 실제 다운로드 실행

```bash
python -m app.cli run --once
```

---

## 5) 상태 확인(status)

```bash
python -m app.cli status
```

출력 항목:

- `last_run_kst`: 최근 실행 시각(KST)
- `last_ok_count`: 최근 실행에서 실제 저장(OK)된 수
- `last_exit_code`: 최근 실행 종료 코드
- `failures_by_reason`: 실패 사유별 누적(있는 경우)

> 반복 실행 시 `DUPLICATE`가 늘어나는 것은 정상입니다(중복 제거가 잘 작동하는 것).

---

## 6) Providers(수집 소스) 설정

기본 실행은 내부 기본값을 사용합니다.

직접 지정하려면:

```bash
python -m app.cli run --once --providers "naver,wikimedia,instagram_seed,google"
```

### 6.1 Instagram seed URL 넣기

`seeds/instagram_urls.txt`에 한 줄에 하나씩 넣습니다.

- 게시물 URL: `og:image`를 추출 시도
- 이미지 직링크: 그대로 다운로드 후보로 사용

예시:

```text
https://www.instagram.com/p/xxxxxxxxxxx/
https://instagram.fxxx-xx.fna.fbcdn.net/v/t51.2885-15/....jpg
```

---

## 7) 결과 폴더(어디에 저장되나요?)

기본 저장 구조 예시:

```text
Desktop/Goyoonjung_Photos/
  YYYY-MM-DD/
    naver/
    wikimedia/
    instagram_seed/
    google/
  Organized/
  meta/
    items.jsonl
    failed.jsonl
    dedup.sqlite
    status.json
  logs/
    summary_YYYY-MM-DD.txt
```

- `meta/items.jsonl`: 성공 기록(저장 경로/sha256/해상도 등)
- `meta/failed.jsonl`: 실패/스킵 기록(이유 포함)
- `meta/dedup.sqlite`: 중복 제거 DB

---

## 8) 주기 실행(자동으로 돌리기)

프로젝트에는 `run_loop.py`가 포함되어 있습니다.

- 실행 전 smoke test 수행
- 수집(`app.cli run --once`) 후, 성공 시 `reorganize.py` 실행
- 기본 4시간마다 반복

### 8.1 한 번만 실행하고 종료

```bash
python run_loop.py --once
```

### 8.2 계속 실행(서비스처럼)

```bash
python run_loop.py
```

> 서버/PC를 꺼버리면 당연히 멈춥니다. 항상 켜두는 환경에서만 의미가 있습니다.

---

## 9) 자주 묻는 질문(FAQ)

### Q1. 새로 저장되는 사진이 없어도 정상인가요?
네. 이미 많이 모아둔 경우 대부분이 중복(DUPLICATE)입니다.
`status`에서 종료 코드가 OK(0)이고, summary에 후보/유니크 URL이 나오면 정상 동작일 확률이 큽니다.

### Q2. NOT_IMAGE가 많아요
이미지처럼 보이지만 실제로는 HTML/리다이렉트인 URL이 섞일 수 있습니다.
`--providers`를 줄여서(예: `wikimedia,instagram_seed`) 안정화해보세요.

### Q3. 다운로드 실패(DOWNLOAD_FAIL)가 많아요
일시적인 네트워크 문제거나, 상대 서버 제한/차단일 수 있습니다.
이 프로그램은 우회하지 않고 스킵/기록합니다.

---

## 10) 보안 체크리스트(필수)

- [ ] `.env`는 절대 공유/커밋하지 않기
- [ ] 실행 로그에 키가 노출되지 않는지 확인하기
- [ ] seed 파일에 민감한 개인 URL이 들어가면 공개 저장소에 올리지 않기

---

## 부록) 최소 명령어 모음

```bash
# 설치
python3 -m venv venv && source venv/bin/activate && pip install -r requirements.txt

# 드라이런
python -m app.cli run --once --dry-run

# 실제 실행
python -m app.cli run --once

# 상태
python -m app.cli status
```
